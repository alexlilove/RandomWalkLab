<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>–°–ª—É—á–∞–π–Ω—ã–µ –±–ª—É–∂–¥–∞–Ω–∏—è ‚Äî —Ä–µ—à—ë—Ç–∫–∞ –∏ –æ—Ç—Ä–µ–∑–∫–∏</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #0b0e12;
      color: #e6e6e6;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      user-select: none;
      touch-action: none; /* —á—Ç–æ–±—ã —É–ø—Ä–∞–≤–ª—è—Ç—å –∂–µ—Å—Ç–∞–º–∏ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ */
      -webkit-tap-highlight-color: transparent;
    }
    #wrap { position: fixed; inset: 0; }
    canvas { display: block; width: 100%; height: 100%; }

    /* –í–µ—Ä—Ö–Ω—è—è –ø–ª–∞—à–∫–∞-–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è */
    .banner {
      position: absolute;
      top: 70px; left: 20px; position: absolute; width: 300px;
      background: rgba(30,35,42,0.9);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 6px 25px 3px 14px;
      font-size: 14px;
      line-height: 1.3;
      
      backdrop-filter: blur(2px);
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
      
      pointer-events: auto; /* —á—Ç–æ–±—ã –∫–ª–∏–∫–∞—Ç—å –ø–æ –∫—Ä–µ—Å—Ç–∏–∫—É */
    }
    .banner.hidden {
      display: none;
    }
    .close-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 20px;
      height: 20px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .close-btn:hover {
      opacity: 1;
    }
    .close-btn::before, .close-btn::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 14px;
      height: 2px;
      background: #e6e6e6;
    }
    .close-btn::before {
      transform: translate(-50%, -50%) rotate(45deg);
    }
    .close-btn::after {
      transform: translate(-50%, -50%) rotate(-45deg);
    }

    /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
    .btn {
      position: fixed; display: inline-flex; align-items: center; justify-content: center;
      width: 44px; height: 44px; border-radius: 12px;
      background: rgba(35,40,48,0.95);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 4px 14px rgba(0,0,0,0.3);
      cursor: pointer; user-select: none;
      font-size: 20px;
    }
    .btn:active { transform: translateY(1px); }

    /* ‚Ü©Ô∏è –∏ üîÑ ‚Äî —Å–ø—Ä–∞–≤–∞ —Å–≤–µ—Ä—Ö—É */
    #undo { top: 10px; right: 62px; }
    #reset { top: 10px; right: 10px; }

    /* –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Ä–µ–∂–∏–º–∞ (—Å–ø–ª–æ—à–Ω–æ–π/–ø—Ä–µ—Ä—ã–≤–∏—Å—Ç—ã–π) ‚Äî —Å–ª–µ–≤–∞ —Å–Ω–∏–∑—É */
    #modeToggle {
      left: 10px; bottom: 10px; width: auto; padding: 0 12px; gap: 8px;
      font-size: 14px; height: 40px;
    }
    #modeBadge {
      margin-left: 8px; padding: 2px 8px; border-radius: 999px; font-size: 12px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.08);
    }

    /* –ü–æ–¥—Å–∫–∞–∑–∫–∏ –≤—ã–±–æ—Ä–∞ —Ç–æ—á–µ–∫ */
    .hud { position: fixed; left: 170px;
      bottom: 10px; font-size: 12px; color: #9fb3c8; opacity: 0.85; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="cv"></canvas></div>
  <div class="banner" id="banner">
    <div class="close-btn" id="closeBtn"></div>
   <p> ‚Ä¢ –î–æ–±–∞–≤–ª—è–π—Ç–µ –∏ –ø–µ—Ä–µ–º–µ—â–∞–π—Ç–µ —Ç–æ—á–∫–∏. –£–¥–∞–ª—è–π—Ç–µ —É–¥–µ—Ä–∂–∞–Ω–∏–µ–º. </p>
   <p> ‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ –¥–≤–µ —Ç–æ—á–∫–∏ ‚Äî —á–µ—Ä–µ–∑ –Ω–∏—Ö –ø—Ä–æ–π–¥–µ—Ç –æ—Ç—Ä–µ–∑–æ–∫ (—Å–ø–ª–æ—à–Ω–æ–π –∏–ª–∏ –ø—Ä–µ—Ä—ã–≤–∏—Å—Ç—ã–π).</p>
    <p>‚Ä¢ –î–≤–æ–π–Ω—ã–º —Ç–∞–ø–æ–º –ø–æ —Ç–æ—á–∫–µ —É–¥–∞–ª—è–π—Ç–µ –ø—Ä–æ—Ö–æ–¥—è—â–∏–µ —á–µ—Ä–µ–∑ –Ω–µ–µ –æ—Ç—Ä–µ–∑–∫–∏.</p>
  </div>

  <div id="undo" class="btn" title="–®–∞–≥ –Ω–∞–∑–∞–¥ (‚Ü©Ô∏è)">‚Ü©Ô∏è</div>
  <div id="reset" class="btn" title="–†–µ—Å—Ç–∞—Ä—Ç (üîÑ)">üîÑ</div>

  <div id="modeToggle" class="btn" title="–†–µ–∂–∏–º –æ—Ç—Ä–µ–∑–∫–æ–≤: —Å–ø–ª–æ—à–Ω–æ–π / –ø—Ä–µ—Ä—ã–≤–∏—Å—Ç—ã–π">
    <span id="modeIcon">‚îÅ</span>
    <span id="modeBadge">—Å–ø–ª–æ—à–Ω–æ–π</span>
  </div>

  <div class="hud" id="hud"></div>

  <script>
  (() => {
    const canvas = document.getElementById('cv');
    const ctx = canvas.getContext('2d');

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ü–µ–Ω—ã
    let state = {
      points: [],           // [{id, x, y, selected:false}]
      segments: [],         // [{aId, bId, dashed:false}]
      dashedMode: false,    // —Ç–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è –æ—Ç—Ä–µ–∑–∫–æ–≤
      selection: [],        // –º–∞—Å—Å–∏–≤ id –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Ç–æ—á–µ–∫ (–º–∞–∫—Å 2)
      pan: {x: 0, y: 0},    // —Å–º–µ—â–µ–Ω–∏–µ –º–∏—Ä–∞ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
      scale: 35,            // –ø–∏–∫—Å/–µ–¥–∏–Ω–∏—Ü—É (–±–µ–∑ –∑—É–º–∞ ‚Äî —Ñ–∏–∫—Å.)
    };

    const history = [];
    function pushHistory() { history.push(JSON.stringify(state)); }
    function undo() {
      if (!history.length) return;
      state = JSON.parse(history.pop());
      render();
    }

    // –£—Ç–∏–ª–∏—Ç—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      render();
    }

    function worldToScreen(wx, wy) {
      return [wx * state.scale + state.pan.x + canvas.clientWidth/2, -wy * state.scale + state.pan.y + canvas.clientHeight/2];
    }
    function screenToWorld(sx, sy) {
      const wx = (sx - canvas.clientWidth/2 - state.pan.x) / state.scale;
      const wy = -(sy - canvas.clientHeight/2 - state.pan.y) / state.scale;
      return [wx, wy];
    }

    // –ü–æ–∏—Å–∫/—Å–æ–∑–¥–∞–Ω–∏–µ —Ç–æ—á–µ–∫
    let nextId = 1;
    function keyFromXY(x, y) { return `${x},${y}`; }
    function findPointAtInt(x, y) { return state.points.find(p => p.x === x && p.y === y); }

    function addPoint(ix, iy) {
      if (findPointAtInt(ix, iy)) return null; // —É–∂–µ –µ—Å—Ç—å
      const p = { id: nextId++, x: ix, y: iy, selected: false };
      pushHistory();
      state.points.push(p);
      return p;
    }
    function removePoint(id) {
      const p = state.points.find(pt => pt.id === id);
      if (!p) return;
      pushHistory();
      // —É–¥–∞–ª—è–µ–º –æ—Ç—Ä–µ–∑–∫–∏ —á–µ—Ä–µ–∑ —ç—Ç—É —Ç–æ—á–∫—É
      state.segments = state.segments.filter(s => s.aId !== id && s.bId !== id);
      state.points = state.points.filter(pt => pt.id !== id);
      state.selection = state.selection.filter(i => i !== id);
    }

    function toggleSelectPoint(id) {
      const p = state.points.find(pt => pt.id === id);
      if (!p) return;
      p.selected = !p.selected;
      if (p.selected) {
        state.selection.push(p.id);
        if (state.selection.length > 2) {
          // –æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–≤–µ
          const firstId = state.selection.shift();
          const old = state.points.find(pp => pp.id === firstId); if (old) old.selected = false;
        }
      } else {
        state.selection = state.selection.filter(i => i !== p.id);
      }
    }

    function addOrToggleSegmentBetween(aId, bId) {
      if (aId === bId) return;
      const [minId, maxId] = aId < bId ? [aId, bId] : [bId, aId];
      const idx = state.segments.findIndex(s => (s.aId === minId && s.bId === maxId));
      pushHistory();
      if (idx >= 0) {
        // –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∏–ª—å –ø–æ —Ç–µ–∫—É—â–µ–º—É —Ä–µ–∂–∏–º—É
        state.segments[idx].dashed = state.dashedMode;
      } else {
        state.segments.push({ aId: minId, bId: maxId, dashed: state.dashedMode });
      }
    }

    function removeSegmentsThroughPoint(id) {
      const before = state.segments.length;
      if (!before) return 0;
      pushHistory();
      state.segments = state.segments.filter(s => s.aId !== id && s.bId !== id);
      return before - state.segments.length;
    }

    // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ç–æ—á–∫–∏ (—Å –ø—Ä–∏–≤—è–∑–∫–æ–π –∫ —Ä–µ—à—ë—Ç–∫–µ)
    function movePoint(id, newX, newY) {
      const p = state.points.find(pt => pt.id === id);
      if (!p) return;
      if (p.x === newX && p.y === newY) return;
      pushHistory();
      p.x = newX; p.y = newY;
    }

    // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
    function render() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0, 0, w, h);

      // —Ñ–æ–Ω
      ctx.fillStyle = '#0b0e12';
      ctx.fillRect(0, 0, w, h);

      // –ø—Ä–µ–¥–µ–ª—ã –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
      const [wx0, wy0] = screenToWorld(0, h);
      const [wx1, wy1] = screenToWorld(w, 0);
      const minX = Math.floor(wx0), maxX = Math.ceil(wx1);
      const minY = Math.floor(wy0), maxY = Math.ceil(wy1);

      // —Å–µ—Ç–∫–∞ —Ü–µ–ª—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.beginPath();
      for (let x = minX; x <= maxX; x++) {
        const [sx0, sy0] = worldToScreen(x, minY);
        const [sx1, sy1] = worldToScreen(x, maxY);
        ctx.moveTo(sx0 + 0.5, sy0);
        ctx.lineTo(sx1 + 0.5, sy1);
      }
      for (let y = minY; y <= maxY; y++) {
        const [sx0, sy0] = worldToScreen(minX, y);
        const [sx1, sy1] = worldToScreen(maxX, y);
        ctx.moveTo(sx0, sy0 + 0.5);
        ctx.lineTo(sx1, sy1 + 0.5);
      }
      ctx.stroke();

      // –æ—Å–∏ x=0 –∏ y=0
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.setLineDash([]);
      ctx.beginPath();
      // y-–æ—Å—å
      if (minX <= 0 && maxX >= 0) {
        const [sx0, sy0] = worldToScreen(0, minY);
        const [sx1, sy1] = worldToScreen(0, maxY);
        ctx.moveTo(sx0 + 0.5, sy0);
        ctx.lineTo(sx1 + 0.5, sy1);
      }
      // x-–æ—Å—å
      if (minY <= 0 && maxY >= 0) {
        const [sx0, sy0] = worldToScreen(minX, 0);
        const [sx1, sy1] = worldToScreen(maxX, 0);
        ctx.moveTo(sx0, sy0 + 0.5);
        ctx.lineTo(sx1, sy1 + 0.5);
      }
      ctx.stroke();

      // –æ—Ç—Ä–µ–∑–∫–∏
      for (const s of state.segments) {
        const a = state.points.find(p => p.id === s.aId);
        const b = state.points.find(p => p.id === s.bId);
        if (!a || !b) continue;
        const [sx, sy] = worldToScreen(a.x, a.y);
        const [tx, ty] = worldToScreen(b.x, b.y);
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = '#6fd3ff';
        ctx.setLineDash(s.dashed ? [8, 8] : []);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(tx, ty);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // —Ç–æ—á–∫–∏
      for (const p of state.points) {
        const [sx, sy] = worldToScreen(p.x, p.y);
        ctx.beginPath();
        ctx.arc(sx, sy, 5, 0, Math.PI*2);
        ctx.fillStyle = p.selected ? '#ffd166' : '#e6e6e6';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = p.selected ? 'rgba(255,209,102,0.7)' : 'rgba(255,255,255,0.35)';
        ctx.stroke();
      }

      // HUD
      document.getElementById('hud').textContent =
        state.selection.length === 1 ? '–í—ã–±—Ä–∞–Ω–∞ 1 —Ç–æ—á–∫–∞ ‚Äî –≤—ã–±–µ—Ä–∏—Ç–µ –≤—Ç–æ—Ä—É—é –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ç—Ä–µ–∑–∫–∞' :
        state.selection.length === 2 ? '–í—ã–±—Ä–∞–Ω–æ 2 —Ç–æ—á–∫–∏ ‚Äî —Ç–∞–ø–Ω–∏—Ç–µ –ø–æ —Å–≤–æ–±–æ–¥–Ω–æ–º—É –º–µ—Å—Ç—É, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '';
    }

    // –•–∏—Ç-—Ç–µ—Å—Ç —Ç–æ—á–∫–∏ –ø–æ —ç–∫—Ä–∞–Ω–Ω—ã–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
    function hitTestPoint(sx, sy) {
      // –∏—â–µ–º –±–ª–∏–∂–∞–π—à—É—é —Ä–µ—à—ë—Ç—á–∞—Ç—É—é —Ç–æ—á–∫—É –≤ —Ä–∞–¥–∏—É—Å–µ pickR
      const pickR = 12; // px
      // —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ç–æ—á–∫–∏ –ø–æ —ç–∫—Ä–∞–Ω–Ω–æ–º—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
      let best = null, bestD2 = pickR*pickR;
      for (const p of state.points) {
        const [px, py] = worldToScreen(p.x, p.y);
        const dx = px - sx, dy = py - sy;
        const d2 = dx*dx + dy*dy;
        if (d2 <= bestD2) { bestD2 = d2; best = p; }
      }
      return best; // –ª–∏–±–æ null
    }

    // –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –±–ª–∏–∂–∞–π—à–µ–π —Ü–µ–ª–æ–π —Ä–µ—à—ë—Ç–∫–µ
    function snapWorldToInt(wx, wy) {
      return [Math.round(wx), Math.round(wy)];
    }

    // –í–≤–æ–¥: –∂–µ—Å—Ç—ã/–º—ã—à—å
    let dragging = null; // {type:'point'|'pan', id?, start:{sx,sy}, origPan, pressTimer?, moved:false, lastDownTime}
    let lastTapTime = 0; // –¥–ª—è –¥–≤–æ–π–Ω–æ–≥–æ —Ç–∞–ø–∞
    let initialDistance = 0; // –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏
    let initialScale = 0; // –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏

    function pointerDown(e) {
     if (e.touches && e.touches.length >= 2) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        initialDistance = Math.sqrt(dx * dx + dy * dy);
        initialScale = state.scale;
        return;
    }

      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX ?? e.touches?.[0]?.clientX) - rect.left;
      const sy = (e.clientY ?? e.touches?.[0]?.clientY) - rect.top;

      const hit = hitTestPoint(sx, sy);
      dragging = { type: hit ? 'point' : 'pan', id: hit?.id ?? null, start:{sx, sy}, origPan:{...state.pan}, moved:false };

      if (hit) {
        // –∑–∞–ø—É—Å—Ç–∏–º —Ç–∞–π–º–µ—Ä –¥–ª—è –¥–æ–ª–≥–æ–≥–æ —É–¥–µ—Ä–∂–∞–Ω–∏—è (—É–¥–∞–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏)
        dragging.pressTimer = setTimeout(() => {
          // –µ—Å–ª–∏ –≤—Å—ë –µ—â—ë –¥–µ—Ä–∂–∏–º –∏ –Ω–µ –¥–≤–∏–≥–∞–ª–∏ ‚Äî —É–¥–∞–ª—è–µ–º —Ç–æ—á–∫—É (–∏ –µ—ë –æ—Ç—Ä–µ–∑–∫–∏)
          if (dragging && dragging.type==='point' && !dragging.moved) {
            removePoint(hit.id);
            dragging = null; // –∑–∞–≤–µ—Ä—à–∏—Ç—å –∂–µ—Å—Ç
            render();
          }
        }, 550);
      }

      // –¥–≤–æ–π–Ω–æ–π —Ç–∞–ø –ø–æ —Ç–æ—á–∫–µ ‚Äî —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –æ—Ç—Ä–µ–∑–∫–∏ —á–µ—Ä–µ–∑ –Ω–µ—ë (—Ç–æ—á–∫–∞ –æ—Å—Ç–∞—ë—Ç—Å—è)
      const now = performance.now();
      const isDouble = (now - lastTapTime) < 300; // 300 –º—Å –æ–∫–Ω–æ
      lastTapTime = now;
      if (isDouble && hit) {
        const removed = removeSegmentsThroughPoint(hit.id);
        if (dragging?.pressTimer) clearTimeout(dragging.pressTimer);
        dragging = null;
        render();
        return;
      }

      e.preventDefault();
    }

    function pointerMove(e) {
      if (e.touches && e.touches.length >= 2) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        const currentDistance = Math.sqrt(dx * dx + dy * dy);
        
        if (initialDistance > 0) {
            const scaleFactor = currentDistance / initialDistance;
            const newScale = initialScale * scaleFactor;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞—Å—à—Ç–∞–±
            state.scale = Math.max(10, Math.min(200, newScale)); // –ú–∏–Ω–∏–º—É–º 10, –º–∞–∫—Å–∏–º—É–º 200
            render();
        }
        return;
    }

      if (!dragging) return;
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX ?? e.touches?.[0]?.clientX) - rect.left;
      const sy = (e.clientY ?? e.touches?.[0]?.clientY) - rect.top;
      const dx = sx - dragging.start.sx;
      const dy = sy - dragging.start.sy;

      if (dragging.type === 'pan') {
        dragging.moved = true;
        state.pan.x = dragging.origPan.x + dx;
        state.pan.y = dragging.origPan.y + dy;
        render();
      } else if (dragging.type === 'point') {
        // –µ—Å–ª–∏ —Å–º–µ—Å—Ç–∏–ª–∏ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ ‚Äî —ç—Ç–æ –ø–µ—Ä–µ–Ω–æ—Å —Ç–æ—á–∫–∏, –æ—Ç–º–µ–Ω—è–µ–º long-press
        if (Math.hypot(dx,dy) > 4 && dragging.pressTimer) {
          clearTimeout(dragging.pressTimer); dragging.pressTimer = null;
        }
        dragging.moved = true;
        const [wx, wy] = screenToWorld(sx, sy);
        const [ix, iy] = snapWorldToInt(wx, wy);
        // –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–µ–≤—å—é: –¥–≤–∏–≥–∞–µ–º –±–µ–∑ –∏—Å—Ç–æ—Ä–∏–∏, –∏—Å—Ç–æ—Ä–∏—é –¥–æ–±–∞–≤–∏–º –Ω–∞ mouseup
        const p = state.points.find(pt => pt.id === dragging.id);
        if (p) { p.x = ix; p.y = iy; render(); }
      }
      e.preventDefault();
    }

    function pointerUp(e) {
      if (e.touches && e.touches.length >= 2) {
        // –û–±–Ω–æ–≤–ª—è–µ–º initialScale –∏ initialDistance –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        initialDistance = Math.sqrt(dx * dx + dy * dy);
        initialScale = state.scale;
        return;
    }

      if (!dragging) return;
      if (dragging.pressTimer) { clearTimeout(dragging.pressTimer); }
      const rect = canvas.getBoundingClientRect();
      const sx = (e.clientX ?? dragging.start.sx) - rect.left;
      const sy = (e.clientY ?? dragging.start.sy) - rect.top;

      if (dragging.type === 'point') {
        if (!dragging.moved) {
          // —ç—Ç–æ —Ç–∞–ø –ø–æ —Ç–æ—á–∫–µ ‚Äî –≤—ã–±–æ—Ä/—Å–Ω—è—Ç–∏–µ –≤—ã–±–æ—Ä–∞ –∏, –≤–æ–∑–º–æ–∂–Ω–æ, —Å–æ–∑–¥–∞–Ω–∏–µ –æ—Ç—Ä–µ–∑–∫–∞
          const p = state.points.find(pt => pt.id === dragging.id);
          if (p) {
            pushHistory();
            toggleSelectPoint(p.id);
            if (state.selection.length === 2) {
              const [a, b] = state.selection;
              addOrToggleSegmentBetween(a, b);
              // —Å–Ω–∏–º–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
              for (const id of state.selection) {
                const pp = state.points.find(q => q.id === id); if (pp) pp.selected = false;
              }
              state.selection = [];
            }
          }
        } else {
          // –∑–∞–≤–µ—Ä—à–∏–ª–∏ –ø–µ—Ä–µ–Ω–æ—Å —Ç–æ—á–∫–∏ ‚Äî —Ñ–∏–∫—Å–∏—Ä—É–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏ (–∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ)
          pushHistory(); // —É–∂–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–æ–º–µ–Ω—Ç –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è
        }
      } else if (dragging.type === 'pan') {
        // –µ—Å–ª–∏ —ç—Ç–æ –±—ã–ª –∫–ª–∏–∫ –ø–æ –ø—É—Å—Ç–æ–º—É –º–µ—Å—Ç—É, –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å —Ç–æ—á–∫—É –Ω–∞ —É–∑–ª–µ —Ä–µ—à—ë—Ç–∫–∏
        if (!dragging.moved) {
          const [wx, wy] = screenToWorld(sx, sy);
          const [ix, iy] = snapWorldToInt(wx, wy);
          const nearExisting = findPointAtInt(ix, iy);
          if (!nearExisting) {
            addPoint(ix, iy);
          } else {
            // –µ—Å–ª–∏ —Ç–∞–ø –ø–æ –ø—É—Å—Ç–æ–º—É –º–µ—Å—Ç—É, –Ω–æ —Ä—è–¥–æ–º –µ—Å—Ç—å —Ç–æ—á–∫–∞ ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
          }
        }
      }
      dragging = null;
      render();
      e.preventDefault();
    }

    // –ö–Ω–æ–ø–∫–∏
    const undoBtn = document.getElementById('undo');
    const resetBtn = document.getElementById('reset');
    const modeBtn = document.getElementById('modeToggle');
    const modeIcon = document.getElementById('modeIcon');
    const modeBadge = document.getElementById('modeBadge');
    const closeBtn = document.getElementById('closeBtn');
    const banner = document.getElementById('banner');

    undoBtn.addEventListener('click', undo);
    resetBtn.addEventListener('click', () => {
      pushHistory();
      state.points = [];
      state.segments = [];
      state.selection = [];
      render();
    });
    modeBtn.addEventListener('click', () => {
      pushHistory();
      state.dashedMode = !state.dashedMode;
      modeBadge.textContent = state.dashedMode ? '–ø—Ä–µ—Ä—ã–≤–∏—Å—Ç—ã–π' : '—Å–ø–ª–æ—à–Ω–æ–π';
      modeIcon.textContent = state.dashedMode ? '‚ïå' : '‚îÅ';
    });
    closeBtn.addEventListener('click', () => {
      banner.classList.add('hidden');
    });

    // –ü–æ–¥–∫–ª—é—á–∞–µ–º —Å–æ–±—ã—Ç–∏—è (–º—ã—à—å + touch —á–µ—Ä–µ–∑ Pointer Events)
   // –ü–æ–¥–∫–ª—é—á–∞–µ–º —Å–æ–±—ã—Ç–∏—è —á–µ—Ä–µ–∑ Touch Events (–¥–ª—è –º—É–ª—å—Ç–∏—Ç–∞—á–∞) –∏ –º—ã—à—å –æ—Ç–¥–µ–ª—å–Ω–æ
canvas.addEventListener('mousedown', pointerDown);
canvas.addEventListener('mousemove', pointerMove);
window.addEventListener('mouseup', pointerUp);

// Touch Events –¥–ª—è –º—É–ª—å—Ç–∏—Ç–∞—á–∞
canvas.addEventListener('touchstart', pointerDown, {passive: false});
canvas.addEventListener('touchmove', pointerMove, {passive: false});
canvas.addEventListener('touchend', pointerUp);
canvas.addEventListener('touchcancel', pointerUp);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    function init() {
      // –Ω–µ–±–æ–ª—å—à–æ–π —Å–¥–≤–∏–≥, —á—Ç–æ–±—ã (0,0) –±—ã–ª –ø—Ä–∏–º–µ—Ä–Ω–æ –≤ —Ü–µ–Ω—Ç—Ä–µ
      state.pan.x = 0; state.pan.y = 0;
      resize();
      // –ø–µ—Ä–≤–∞—è –∑–∞–ø–∏—Å—å –¥–ª—è –æ—Ç–∫–∞—Ç–∞
      pushHistory();
    }
    window.addEventListener('resize', resize);
    init();
  })();
  </script>
</body>
</html>
